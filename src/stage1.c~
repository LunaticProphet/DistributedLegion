#include "common.h"
#include "stage1.h"

int timestamp = 0;
int prev_in_cs = -1;
int accepts = 0;

int get_timestamp(){
	return timestamp;
}
int get_accept_count(){
	return accepts;
}
int get_prev_in_cs(){
	return prev_in_cs;
}

////////////////////////////////////////

msg tqueue[SLAVENUM];

void tqueue_add(msg *m){
	int i;
	for(i=0;i<SLAVENUM;++i) if(tqueue[i].from == -1){
		tqueue[i] = *m;
		break;
	}
}
void tqueue_del(int from){
	int i;
	for(i=0;i<SLAVENUM;++i) if(tqueue[i].from == from){
		tqueue[i].from = -1;
		break;
	}
}
msg* tqueue_top(){
	int i,best = -1;
	for(i=0;i<SLAVENUM;++i){
		if(tqueue[i].from != -1){
			if(best == -1 || tqueue[i].stmp < tqueue[best].stmp || (tqueue[i].stmp == tqueue[best].stmp && tqueue[i].from < tqueue[best].from)){
				best = i;
			}
		}
	}
	if(best == -1) return 0;
	return &tqueue[best];
}

////////////////////////////////

int hang[SLAVENUM];
void hang_add(int i){
	hang[i] = 1;	
}
void hang_del(int i){
	hang[i] = 0;
}
int hang_contains(int i){
	return hang[i];
}
int hang_count(){
	int i,c=0;
	for(i=0;i<SLAVENUM;++i) if(hang_contains(i)) ++c;
	return c;
}

void stage1_init(){
	int i;
	for(i=0;i<SLAVENUM;++i) tqueue[i].from = -1;
	for(i=0;i<SLAVENUM;++i) hang[i] = 0;
}

////////////////////////////////

void send_with_ts(int id, msg *m, int ts){
	int myid = my_id();
	pvm_initsend(PvmDataDefault);
	pvm_pkint(&(m->type),	1,1);
	pvm_pkint(&(ts),	1,1);
	pvm_pkint(&myid,		1,1);
	pvm_pkint(&(m->data),	1,1);
	pvm_pkint(&(m->road),	1,1);
	pvm_send(tid(id), MSG_COMM);
	//sprintf(buf,"SND%i type=%i stmp=%i from=%i",id,m->type,ts,myid); lg();
}
void send(int id, msg *m){
	send_with_ts(id, m, ++timestamp);
}
int trecv(int usec, msg *m){
	struct timeval t;
	t.tv_sec = 0;
	t.tv_usec = usec*1000;
	int e = pvm_trecv(-1, MSG_COMM, &t);
	if(e <= 0) return 0;
	pvm_upkint(&(m->type), 	1,1);
	pvm_upkint(&(m->stmp),	1,1);
	pvm_upkint(&(m->from), 	1,1);
	pvm_upkint(&(m->data), 	1,1);
	pvm_upkint(&(m->road), 	1,1);
	if(m->stmp > timestamp) timestamp = m->stmp;
	//sprintf(buf,"RECV type=%i stmp=%i from=%i",m->type,m->stmp,m->from); lg();
	return 1;
}
void send_req_to(int id, int ts){
	msg t;
	t.type = M_REQ;
	t.data = prev_in_cs;
	send_with_ts(id, &t, ts);
}
void send_rel_to(int id){
	msg t;
	t.type = M_REL;
	t.data = my_id();
	send(id, &t);
}
void send_acc_to(int id){
	msg t;
	t.type = M_ACC;
	t.data = prev_in_cs;
	send(id, &t);
}
void handle_req_acc_rel(msg *m){
	msg *t;
	if(m->data > prev_in_cs) prev_in_cs = m->data;
	switch(m->type){
		case M_ACC:
				accepts++;
			break;
		case M_REQ:	
				tqueue_add(m);
				t = tqueue_top();
				if(t->from == m->from)
					send_acc_to(m->from);
				else
					hang_add(m->from);
			break;
		case M_REL:
				tqueue_del(m->from);
				t = tqueue_top();
				if(t != 0)
					if(hang_contains(t->from)){
						hang_del(t->from);
						send_acc_to(t->from);
					}
			break;

		default:
			sprintf(buf, "HOUSTON..."); 
			lg();
	}
	//usleep(500000);
}
void stage1_enter_cs(int road, void (*event)(int), void (*msg_handler)(msg*)){
	int i,ts = get_timestamp();
	msg m;
	for(i=0;i<peer_count();++i)
		send_req_to(i,ts);

	while(get_accept_count() != peer_count() || tqueue_top()->from != my_id())
		if(trecv(1000,&m))
			msg_handler(&m);

	event(get_prev_in_cs());

	for(i=0;i<peer_count();++i)
		send_rel_to(i);

	while(hang_count() > 0)
		if(trecv(1000, &m))
			msg_handler(&m);
}
